.\" Automatically generated by Pod::Man version 1.15
.\" Sun Apr 22 22:26:21 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "AnyDBD 3"
.TH AnyDBD 3 "perl v5.6.1" "2001-04-22" "User Contributed Perl Documentation"
.UC
.SH "NAME"
DBIx::AnyDBD \- \s-1DBD\s0 independant class
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides application developers with an abstraction class
a level away from \s-1DBI\s0, that allows them to write an application that
works on multiple database platforms. The idea isn't to take away the
responsibility for coding different \s-1SQL\s0 on different platforms, but
to simply provide a platform that uses the right class at the right
time for whatever \s-1DB\s0 is currently in use.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use DBIx::AnyDBD;
.Ve
.Vb 2
\&    my $db = DBIx::AnyDBD->connect("dbi:Oracle:sid1", 
\&        "user", "pass", {}, "MyClass");
.Ve
.Vb 2
\&    my $foo = $db->foo;
\&    my $blee = $db->blee;
.Ve
That doesn't really tell you much... Because you have to implement a
bit more than that. Underneath you have to have a module 
MyClass::Oracle that has methods \fIfoo()\fR and blee in it. If those
methods don't exist in MyClass::Oracle, it will check in MyClass::Default,
allowing you to implement code that doesn't need to be driver
dependant in the same module. The \fIfoo()\fR and \fIblee()\fR methods will recieve
the DBIx::AnyDBD instance as thier first parameter, and any parameters
you pass just go as parameters.
.PP
See the example Default.pm and Sybase.pm classes in the AnyDBD directory
for an example.
.SH "Implementation"
.IX Header "Implementation"
Underneath it's all implemented using the \s-1ISA\s0 hierarchy, which is modified 
when you connect to your database. The inheritance tree ensures that the
right functions get called at the right time. There is also an AUTOLOADer
that steps in if the function doesn't exist and tries to call the function
on the database handle (i.e. in the \s-1DBI\s0 class). The sub-classing uses
\&\f(CW\*(C`ucfirst($dbh\-\*(C'\fR{Driver}\->{Name})> (along with some clever fiddling for
\&\s-1ODBC\s0 and \s-1ADO\s0) to get the super-class, so if you don't know what to name
your class (see the list below first) then check that.
.SH "API"
.IX Header "API"
.Sh "new( ... )"
.IX Subsection "new( ... )"
.Vb 5
\&    dsn => $dsn, 
\&    user => $user, 
\&    pass => $pass, 
\&    attr => $attr,
\&    package => $package
.Ve
\&\fInew()\fR is a named parameter call that connects and creates a new db object
for your use. The named parameters are dsn, user, pass, attr and package.
The first 4 are just the parameters passed to \s-1DBI-\s0>connect, and package
contains the package prefix for your database dependant modules, for example,
if package was \*(L"MyPackage\*(R", the AUTOLOADer would look for 
MyPackage::Oracle::func, and then MyPackage::Default::func. Beware that the
\&\s-1DBD\s0 driver will be ucfirst'ed, because lower case package names are reserved
as pragmas in perl. See the known \s-1DBD\s0 package mappings below.
.PP
If package parameter is undefined then the package name used to call
the constructor is used.  This will usually be DBIx::AnyDBD.  This, in
itself, is not very useful but is convenient if you subclass
DBIx::AnyDBD.
.PP
If attr is undefined then the default attributes are:
.PP
.Vb 3
\&    AutoCommit => 1
\&    PrintError => 0
\&    RaiseError => 1
.Ve
So be aware if you don't want your application dying to either eval{} all
db sections and catch the exception, or pass in a different attr parameter.
.PP
After re-blessing the object into the database specific object, DBIx::AnyDBD
will call the \fI_init()\fR method on the object, if it exists. This allows you
to perform some driver specific post-initialization.
.Sh "connect($dsn, \f(CW$user\fP, \f(CW$pass\fP, \f(CW$attr\fP, \f(CW$package\fP)"
.IX Subsection "connect($dsn, $user, $pass, $attr, $package)"
\&\fIconnect()\fR is very similar to \s-1DBI-\s0>connect, taking exactly the same first
4 parameters. The 5th parameter is the package prefix, as above.
.PP
\&\fIconnect()\fR doesn't try and default attributes for you if you don't pass them.
.PP
After re-blessing the object into the database specific object, DBIx::AnyDBD
will call the \fI_init()\fR method on the object, if it exists. This allows you
to perform some driver specific post-initialization.
.Sh "$db->\fIget_dbh()\fP"
.IX Subsection "$db->get_dbh()"
This method is mainly for the \s-1DB\s0 dependant modules to use, it returns the
underlying \s-1DBI\s0 database handle. There will probably have code added here
to check the db is still connected, so it may be wise to always use this
method rather than trying to retrieve \f(CW$self\fR->{dbh} directly.
.SH "Known DBD Package Mappings"
.IX Header "Known DBD Package Mappings"
The following are the known \s-1DBD\s0 driver name mappings, including ucfirst'ing
them:
.PP
.Vb 6
\&    DBD::Oracle => Oracle.pm
\&    DBD::Sybase => Sybase.pm
\&    DBD::Pg => Pg.pm
\&    DBD::mysql => Mysql.pm
\&    DBD::Informix => Informix.pm
\&    DBD::AdabasD => AdabasD.pm
.Ve
If you use this on other platforms, let me know what the mappings are.
.Sh "\s-1ODBC\s0"
.IX Subsection "ODBC"
\&\s-1ODBC\s0 needed special support, so when run with \s-1DBD::ODBC\s0, we call GetInfo
to find out what database we're connecting to, and then map to a known package.
The following are the known package mappings for \s-1ODBC:\s0
.PP
.Vb 7
\&    Microsoft SQL Server (7.0 and MSDE) => MSSQL.pm
\&    Microsoft SQL Server (6.5 and below) => Sybase.pm (sorry!)
\&    Sybase (ASE and ASA) => Sybase.pm
\&    Microsoft Access => Access.pm
\&    Informix => Informix.pm
\&    Oracle => Oracle.pm
\&    Adabas D => AdabasD.pm
.Ve
Anything that isn't listed above will get mapped using the following rule:
.PP
.Vb 3
\&    Get rdbms name using: $dbh->func(17, GetInfo);
\&    Change whitespace to a single underscore
\&    Add .pm on the end.
.Ve
So if you need to know what your particular database will map to, simply run
the \f(CW$dbh\fR->func(17, GetInfo) method to find out.
.PP
\&\s-1ODBC\s0 also inserts \f(CW\*(C`$package::ODBC.pm\*(C'\fR into the hierarchy if it exists, so
the hierarchy will look like:
.PP
.Vb 1
\&    DBIx::AnyDBD <= ODBC.pm <= Informix.pm
.Ve
(given that the database you're connecting to would be Informix). This is
useful because \s-1ODBC\s0 provides its own \s-1SQL\s0 abstraction layer.
.Sh "\s-1ADO\s0"
.IX Subsection "ADO"
\&\s-1ADO\s0 uses the same semantics as \s-1ODBC\s0 for determining the right driver or
module to load. However in extension to that, it inserts an \s-1ADO\s0.pm into
the inheritance hierarchy if it exists, so the hierarchy would look like:
.PP
.Vb 1
\&    DBIx::AnyDBD <= ODBC.pm <= ADO.pm <= Informix.pm
.Ve
I do understand that this is not fundamentally correct, as not all \s-1ADO\s0
connections go through \s-1ODBC\s0, but if you're doing some of that funky stuff
with \s-1ADO\s0 (such as queries on \s-1MS\s0 Index Server) then you're not likely to
need this module!
.SH "Controlling error propagation from AUTOLOADed DBI methods"
.IX Header "Controlling error propagation from AUTOLOADed DBI methods"
Typicially the implementation packages will make calls to \s-1DBI\s0 methods
as though they were methods of the DBIx::AnyDBD object.  If one of
these methods reports an error in \s-1DBI:\s0:AnyDBD then the error is caught
and rethrown by DBIx::AnyDBD so that the error is reported as occuring
in the implementation module.  It does this by calling \fICarp::croak()\fR
with the current package set to DBIx::AnyDBD::Carp.
.PP
Usually this the the right thing to do but sometimes you may want to
report the error in the line containing the original method call on
the DBIx::AnyDBD object.  In this case you should temporarily set
\&\f(CW@DBIx::AnyDBD::Carp::ISA\fR.
.PP
.Vb 2
\&    my $db = DBIx::AnyDBD->connect("dbi:Oracle:sid1", 
\&        "user", "pass", {}, "MyClass");
.Ve
.Vb 2
\&    my $foo = $db->foo;
\&    my $blee = $db->blee("too few arguments"); # Error reported here
.Ve
.Vb 1
\&    package MyClass::Oracle;
.Ve
.Vb 3
\&    sub foo { 
\&        shift->prepare("Invalid SQL"); # Error reported here
\&    }
.Ve
.Vb 4
\&    sub blee {
\&        local @DBIx::AnyDBD::Carp::ISA = __PACKAGE__;
\&        shift->selectall_arrayref(BLEE_STATEMENT,{},@_); # Error not reported here
\&    }
.Ve
.SH "LICENCE"
.IX Header "LICENCE"
This module is free software, and you may distribute it under the same 
terms as Perl itself.
.SH "SUPPORT"
.IX Header "SUPPORT"
Commercial support for this module is available on a pay per incident
basis from Fastnet Software Ltd. Contact matt@sergeant.org for further
details. Alternatively join the DBI-Users mailing list, where I'll help
you out for free!
